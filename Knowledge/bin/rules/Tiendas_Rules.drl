package dynagent.ruleengine.src.ruler.ERPrules
import dynagent.ruleengine.src.ruler.*;
import dynagent.ruleengine.src.ruler.ERPrules.datarules.*;
import java.util.*;
import dynagent.common.properties.*;
import dynagent.common.properties.values.*;
import dynagent.common.knowledge.*;
import dynagent.common.basicobjects.*;
import dynagent.ruleengine.meta.api.*;
import dynagent.ruleengine.CreateIdo;
import dynagent.common.utils.Auxiliar;
import dynagent.common.Constants;
import dynagent.common.exceptions.*;
import org.drools.WorkingMemory;

import java.text.*;

global DataModelAdapter dma;

function  boolean separadosAlMenosNdias(Date d1,Date d2, int ndias){
		boolean result=false;
		Long dif=Math.abs(d1.getTime()-d2.getTime());
		Long msecondsNdias=new Long((long)ndias*24*3600*Constants.TIMEMILLIS);
		return dif>msecondsNdias;
} 

rule "IMPORTE EN BASE A ENTREGADO"
agenda-group "rules" when 
	
	FactHierarchy(idtoTicket:IDTO,CLASSSUP=="TICKET")	
	DatValue(IDTO==idtoTicket,idoDoc:IDO, PROPNAME=="importe",importeDoc:DOUBLEVALUE!=null)
	
	ObjValue(IDO==idoDoc,PROPNAME=="cobro_anticipo",idoCobro:IDOVALUE,ovCobro:OBJECTVALUE)
	Lock(IDO==idoCobro,idtoCobro:IDTO,STATE==Constants.INDIVIDUAL_STATE_LOCK)
    //not(DatValue(IDO==idoCobro,PROPNAME=="importe",DOUBLEVALUE!=null))	

	entrgMet:Double()	from accumulate(DatValue(IDO==idoCobro,PROPNAME=="entregado_metálico",i:DOUBLEVALUE!=null),
                      							 sum(i))	 
                      									
	totalAnticipadoResto:Double()	from accumulate((and 	ObjValue(IDO==idoDoc,PROPNAME=="cobro_anticipo",idoCobroAny:IDOVALUE!=idoCobro)
    				 									DatValue(IDO==idoCobroAny,PROPNAME=="importe",i:DOUBLEVALUE!=null)),
                      									sum(i))	 
then
	dma.printRule("==========IMPORTE EN BASE A ENTREGADO " +entrgMet);
		
	Double importePendienteCobro=importeDoc-totalAnticipadoResto;
	if(importeDoc.doubleValue()==0.0){
		dma.printRule("Recortamos a cero");
		dma.setValue(idoCobro,idtoCobro,"importe",new DoubleValue(0.0));
		dma.setValue(idoCobro,idtoCobro,"devuelto_metálico",new DoubleValue(0.0));
	}else{		
		if(entrgMet.doubleValue()!=0.0){		
			double importe=Math.min(importePendienteCobro,entrgMet);
			dma.setValue(idoCobro,idtoCobro,"importe",new DoubleValue(importe));
			dma.setValue(idoCobro,idtoCobro,"devuelto_metálico",new DoubleValue(Auxiliar.redondea(entrgMet-importe,2)));
			dma.consumirEventoCambio(idoCobro,"entregado_metálico");
		}else{
			DoubleValue importeCobroOld=(DoubleValue)dma.getValue(idoCobro,idtoCobro,"importe");
			if(importeCobroOld==null)
				dma.setValue(idoCobro,idtoCobro,"importe",new DoubleValue(importePendienteCobro));
		}
	}	
end


rule "NO SE PUEDE CONFIRMAR UN TICKET VENTA SI NO HA SIDO PAGADO"
salience 100
agenda-group "rules" when 
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	Lock(IDTO==idtoVenta,idDoc:ID!=null,IDO<0,STATE==Constants.INDIVIDUAL_STATE_END_LOCK)
	
	//DatValue(ID==idDoc, PROPNAME=="rectificativo",BOOLEANVALOR=="true")
	DatValue(ID==idDoc, PROPNAME=="importe",importe:DOUBLEVALUE!=null)
	DatValue(ID==idDoc, PROPNAME=="entregado_metálico",DOUBLEVALUE!=null)//debe existir entregado

	totalAnticipado:Double()	from accumulate((and 	ObjValue(ID==idDoc,PROPNAME=="cobro_anticipo",idoCobroAny:IDOVALUE)
    				 									DatValue(IDO==idoCobroAny,PROPNAME=="importe",i:DOUBLEVALUE!=null)),
                      									sum(i))	 	
	eval(Auxiliar.redondea(importe-totalAnticipado,2)>=0.01)
then
	Double restoporpagar=importe-totalAnticipado;
	dma.printRule("\n\n===========RULE NO SE PUEDE CONFIRMAR UN TICKET VENTA SI NO HA SIDO PAGADO idDoc="+idDoc+"  importe="+importe+"  totalEntregadoDinero="+totalAnticipado );
	throw new OperationNotPermitedException("El ticket aún no se ha pagado. Faltan "+Auxiliar.redondea(restoporpagar,2)+"  euros.</b>"+
											"Un ticket es anónimo, para que un documento quede con deuda debe ser nominativo, como un albarán.");
end

rule "ABONOS: CANTIDAD SIEMPRE NEGATIVA EN ARTICULOS EXISTEN EN TICKET CARGO"
salience -100
agenda-group "rules" when 
	FactHierarchy(idtoTicket:IDTO,CLASSSUP=="TICKET")

	Lock(IDTO==idtoTicket,idoAbono:IDO,STATE==Constants.INDIVIDUAL_STATE_LOCK)
	ObjValue(IDO==idoAbono, PROPNAME=="rectifica_a",idoTicketCargo:IDOVALUE!=null)	
	ObjValue(IDO==idoAbono, PROPNAME=="línea",idoLineaAbono:IDOVALUE,idtoLinea:VALUECLS)
	ObjValue(IDO==idoLineaAbono, PROPNAME=="producto",producto:IDOVALUE!=null)

	
	ObjValue(IDO==idoTicketCargo, PROPNAME=="línea",idoLineaCargo:IDOVALUE)	
	ObjValue(IDO==idoLineaCargo, PROPNAME=="producto",IDOVALUE==producto)
	DatValue(IDO==idoLineaCargo, PROPNAME=="cantidad",QMIN>0,PREVIODOUBLEVALUE==null||>0)//descartar que previamente sea negativo en cuyo caso puede ser un valor positivo forzado por usuario

	DatValue(IDO==idoLineaCargo,PROPNAME=="precio",precioCargo:QMIN!=null)
	DatValue(IDO==idoLineaCargo,PROPNAME=="precio_iva_incluido",precioIICargo:QMIN!=null)
	
	existeOtraLineaMismaKey:Long() from accumulate((and ObjValue(IDO==idoAbono, PROPNAME=="línea",idoLineaAbono2:IDOVALUE!=idoLineaAbono)
														ObjValue(IDO==idoLineaAbono2, PROPNAME=="producto",IDOVALUE==producto)),count(idoLineaAbono2))
	qAbono:Double() from accumulate(DatValue(IDO==idoLineaAbono, PROPNAME=="cantidad",q:QMIN!=null),sum(q))
then	
	dma.printRule("\n\n===========ABONOS: CANTIDAD SIEMPRE NEGATIVA EN ARTICULOS EXISTEN EN TICKET CARGO" );
	if(qAbono.doubleValue()>0 && existeOtraLineaMismaKey.intValue()==0){
		dma.setValue(idoLineaAbono,idtoLinea,"cantidad",new DoubleValue(-qAbono.doubleValue()));
	}
	dma.printRule(" abonar mismo precio y condicion ");
	
	dma.setDoubleValue(idoLineaAbono,idtoLinea,dma.getIdProperty("precio"),precioCargo,false);
	dma.setDoubleValue(idoLineaAbono,idtoLinea,dma.getIdProperty("precio_iva_incluido"),precioIICargo,false);
	dma.consumirEventoCambio(idoLineaAbono,"cantidad");
	dma.consumirEventoCambio(idoLineaAbono,"precio");
	dma.consumirEventoCambio(idoLineaAbono,"precio_iva_incluido");
	dma.consumirEventoCambio(idoLineaAbono,"producto");
	dma.consumirEventoCambio(idoLineaAbono,"talla");
	dma.consumirEventoCambio(idoLineaAbono,"color");
end

rule "ENTREGADO METÁLICO EN TICKET IMPORTE CERO"
salience -50 //Menos prioridad que ENTREGADO METALICO TICKET: DEPENDENCIA ANTICIPOS, y que calculo importe total
agenda-group "rules" when 	
	FactHierarchy(cls:CLASSSUP=="TICKET_VENTA",idto:IDTO)	
	Lock(IDTO==idto,ido:IDO,STATE==Constants.INDIVIDUAL_STATE_LOCK)
	existeImportesLinea:Long() from accumulate((and	ObjValue(IDO==ido,PROPNAME=="línea",idoLin:IDOVALUE!=null)
													DatValue(IDO==idoLin,PROPNAME=="importe",QMIN!=null)),count(idoLin))
				
	DatValue(IDO==ido, PROPNAME=="importe",previo:PREVIODOUBLEVALUE,curr:QMIN!=null)
	
	//anticipos:ArrayList() from collect(ObjValue(IDO==ido,PROPNAME=="cobro_anticipo",IDOVALUE!=null))											
then
	dma.printRule("=================ENTREGADO METÁLICO EN TICKET IMPORTE CERO "+previo+" "+curr);
	// El problema es que entregado metalico es un campo grafico ( GUI asistido por reglas ), y por tanto en ciertas condiciones hay que anularlo, ya que de lo contrario las reglas razonan que debe existir un cobro
	// de tarjeta
	//	pruebas soporta:
	// Se abona un ticket (regla añade lineas ya pone entregado metalico a cero), y añades mismo producto, por tanto se agregan lineas. Antes de eso se anulara entregado metalico
	// despues volvemos a poner el mismo producto. Como existe unalinea con ese articulo ya no se le pone cantidad negativa automaticamente (reglas celop), y es positivo
	//es necesario consumir ya que si no en el primer paso (linea agregada cantidad cero, importe doc con previo valor negativo), se resetearia entregado metalico=0  
	//Probar tambien, habiendo abono prendas total negativo, añadir mas lineas positivas otras prendas para que total sea positivo
	
	if(existeImportesLinea.intValue()>0 && curr.doubleValue()==0.0 && !(previo!=null&&previo.doubleValue()==0.0)){
		dma.printRule("set Entregado met. a cero");
		dma.setValue(ido,idto,"entregado_metálico",new DoubleValue(0.0));
		dma.consumirEventoCambio(ido,"importe");
	}
	
	if(	curr.doubleValue()==0.0 && existeImportesLinea.intValue()==0 || 
		previo!=null && (previo.doubleValue()*curr.doubleValue()<0.0 || previo.doubleValue()==0.0 && curr.doubleValue()>0.0)){
		
		DoubleValue em=(DoubleValue)dma.getValue(ido,idto,"entregado_metálico");
		if(em!=null){
			dma.printRule("reset Entregado metalico");
			dma.delValuesNotLock(ido,idto,"entregado_metálico");
			dma.delValues(ido, idto, "cobro_anticipo");
			/*for(int i=0;i<anticipos.size();i++){		
				ObjValue oba=(ObjValue)anticipos.get(i);		
				dma.delValue(ido, idto, "cobro_anticipo", oba.getOBJECTVALUE());								
			}*/
		}
	}	
end

rule "NO SE PUEDE ABONAR UN TICKET VENTA SI HAN PASADO EL MAXIMO DIAS PERMITIDO"
agenda-group "rules" when 
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	Lock(IDTO==idtoVenta,idDoc:ID,STATE==Constants.INDIVIDUAL_STATE_LOCK)
	DatValue(ID==idDoc, PROPNAME=="rectificativo",BOOLEANVALOR=="true")
	DatValue(ID==idDoc,PROPNAME=="fecha",dateAbono:DATE!=null)
	ObjValue(ID==idDoc, PROPNAME=="rectifica_a",idTicketVenta:VALOR!=null)
	DatValue(ID==idTicketVenta,PROPNAME=="fecha",dateTicketVenta:DATE!=null)
	ObjValue(CLASSNAME=="APLICACIÓN", PROPNAME=="config_tickets",configTick:VALOR!=null)
	DatValue(ID==configTick, PROPNAME=="período_días_abonable", ndiasMaragen:INTVALUE!=null)
	eval(separadosAlMenosNdias(dateAbono,dateTicketVenta,ndiasMaragen))//MENOS DE N DIAS DESDE LA VENTA
then
	System.err.println("\n\n ================= RULE NO SE PUEDE ABONAR UN TICKET VENTA SI HAN PASADO EL MAXIMO DIAS PERMITIDO: díasMargenParaAbono="+ndiasMaragen+"  dateAbono="+dateAbono+" dateTicketVenta="+dateTicketVenta);
	throw new OperationNotPermitedException("Ha pasado el plazo permitido para abonar "+ndiasMaragen+" (días)");
end


rule "PRECARGA DOCUMENTOS EN ABONO"
salience 100 //mas prioridad que PRECARGA DOCUMENTOS EN ABONO
agenda-group "rules" when 
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	Individual(IDTO==idtoVenta,idoAbono:IDO,STATE==Constants.INDIVIDUAL_STATE_READY)
	DatValue(IDO==idoAbono, PROPNAME=="rectificativo",BOOLEANVALOR=="true")
	ObjValue(IDO==idoAbono,PROPNAME=="rectifica_a",ticketVenta:OBJECTVALUE!=null)
	eval( dma.preload(ticketVenta.getValue(), ticketVenta.getValueCls()) )
then
	dma.printRule("========== PRECARGA DOCUMENTOS EN ABONO ");
	HashMap<String, Value> values=new HashMap<String, Value> ();
	values.put("rectifica_a",ticketVenta);
	instance instancefilter=dma.buildInstanceWith("TICKET", values,null,null,null);
	HashSet<IDIndividual> idosAbonos=dma.loadIndividualsWithSatisficedFilter(instancefilter);
	dma.printRule("....abonos encontrados sobre el ticket: "+ticketVenta+"  idosAbonos="+idosAbonos);
	
	values=new HashMap<String, Value> ();
	values.put("rectifica_a",new ObjectValue(idoAbono,idtoVenta));
	instancefilter=dma.buildInstanceWith("TICKET", values,null,null,null);
	idosAbonos=dma.loadIndividualsWithSatisficedFilter(instancefilter);
	dma.printRule("....abonos encontrados sobre el ticket: "+idoAbono+"  idosAbonos="+idosAbonos);
end

rule "ABONO: ADVERTENCIA TODO ABONADO"
salience -200 
agenda-group "rules" when 
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	Lock(IDTO==idtoVenta,idoAbono:IDO,STATE==Constants.INDIVIDUAL_STATE_LOCK)
	DatValue(IDO==idoAbono, PROPNAME=="rectificativo",BOOLEANVALOR=="true")
	ObjValue(IDO==idoAbono,PROPNAME=="rectifica_a",idoVenta:IDOVALUE!=null)
	not(ObjValue(IDO==idoAbono,PROPNAME=="línea",IDOVALUE!=null))	
	
	otrosAbonos:String(length>0) from accumulate((and 	ObjValue(idoAbonoAny:IDO!=idoAbono,PROPNAME=="rectifica_a",IDOVALUE==idoVenta)
													DatValue(IDO==idoAbonoAny,PROPNAME=="rdn",rdnAbono:VALOR!=null))
											init(String res="";),
											action(
												if(!res.contains(" "+rdnAbono+" ")){
													res+=" "+rdnAbono+" ";
												};),
											result(res))
then
	dma.printRule("========== ABONO: ADVERTENCIA TODO ABONADO ");
	dma.showMessage("El ticket de cargo ya esta abonado por los ticket "+otrosAbonos);
end


rule "AL SELECCIONAR EL TICKET_CARGO DE UN ABONO SE ASIGNAN PRODUCTOS AÚN NO ABONADOS"
agenda-group "rules" when 
	
	FactHierarchy(idtoAbono:IDTO,CLASSSUP=="TICKET"||=="RECTIFICACIÓN")
	//Locked by user puesto que podemos abonar un ticket, que ya tenia abono parcial anterior, y no debe actuar sobre dicho abono
	Lock(IDTO==idtoAbono,idoAbono:IDO<0,STATE==Constants.INDIVIDUAL_STATE_LOCK,LOCKEDBYUSER==true)
	forall(	FactHierarchy(IDTO==idtoAbono,CLASSSUP=="TICKET")		
			DatValue(IDO==idoAbono, PROPNAME=="rectificativo",BOOLEANVALOR=="true"))
			
	ObjValue(IDO==idoAbono,PROPNAME=="rectifica_a",idoRectificado:IDOVALUE,ticketVenta:VALOR!=null)
	
	ObjValue(ID==ticketVenta, PROPNAME=="línea",idoLineaVenta:IDOVALUE!=null)	
	DatValue(IDO==idoLineaVenta,idtoLineaVenta:IDTO,PROPNAME=="clave_producto", key:VALOR!=null)
	ObjValue(IDO==idoLineaVenta,PROPNAME=="producto", idtoProducto:VALUECLS)
	
	not((and 	ObjValue(IDO==idoAbono,PROPNAME=="línea",lineaAbonoAny:VALOR)
				DatValue(ID==lineaAbonoAny,PROPNAME=="clave_producto", VALOR==key)))
	
	//Que no haya habido interacción del usuario eliminando una linea
	not((and not(FactHierarchy(IDTO==idtoProducto,CLASSSUP=="ARTÍCULO_FINANCIERO"))
				ObjValue(IDO==idoAbono,PROPNAME=="línea",VALOR==null)))

	cantidadVendida:Double() 
   	from accumulate(
             	(and 	             	             	
	             	ObjValue(ID==ticketVenta, PROPNAME=="línea",linea:VALOR!=null)
             		DatValue(ID==linea,PROPNAME=="clave_producto", VALOR==key)
             		DatValue(ID==linea,PROPNAME=="cantidad",cantidad:DOUBLEVALUE!=null)             										
			    ),
			    sum(cantidad))
			    
	cantidadAbonada:Double() 
   	from accumulate(
             	(and 
	             	ObjValue(abono:ID,PROPNAME=="rectifica_a",VALOR==ticketVenta)
	             	ObjValue(ID==abono, PROPNAME=="línea",linea:VALOR!=null)
             		DatValue(ID==linea,PROPNAME=="clave_producto",VALOR==key)
             		DatValue(ID==linea,PROPNAME=="cantidad",cantidad:DOUBLEVALUE!=null)             								
			    ),
			    sum(cantidad))

	//Si es articulo financiero no impongo la condicion de cantidad disponible, ya que aunque no haya cantidad de euros disponible debo añadir la
	//linea de tarjeta de credito para que restaurar su consumo.
	not((and forall(ObjValue(IDO==idoLineaVenta,PROPNAME=="tarjeta", tarjeta:VALOR!=null)							
					ObjValue(idCredito:ID,CLASSNAME=="CRÉDITO_TARJETA",PROPNAME=="documento_activación",VALOR==ticketVenta))
			 eval(cantidadVendida+cantidadAbonada<=0)))
		
	inicializData:ArrayList() from collect(ObjValue(IDO==idoRectificado, PROPNAME=="cliente"||=="proveedor",VALOR!=null))
	inicializado:ArrayList() from collect(ObjValue(IDO==idoAbono, PROPNAME=="línea"||=="cargo"))
then
	dma.printRule("=========== AL SELECCIONAR EL TICKET_CARGO DE UN ABONO SE ASIGNAN PRODUCTOS AÚN NO ABONADOS  productosYaAbonados="+cantidadAbonada);

	Double cantidadDisponible=cantidadVendida+cantidadAbonada;

	String excluproperties="documento#cantidad";	

	Domain newlineaAbono=dma.cloneIndividual(idoLineaVenta, idtoLineaVenta, idtoLineaVenta, excluproperties);	
	dma.setValue(newlineaAbono,"cantidad",new DoubleValue(-cantidadDisponible));
	//dma.setValue(newlineaAbono,"producto",producto);

	//Debo consumir los cambios que dispararian el calculo de iva de la linea, ya que debe respetarse el anterior	
	dma.consumirEventoCambio(newlineaAbono.getIdo(),"producto");
	dma.consumirEventoCambio(newlineaAbono.getIdo(),"cantidad");
	dma.consumirEventoCambio(newlineaAbono.getIdo(),"precio");
	dma.consumirEventoCambio(newlineaAbono.getIdo(),"descuento");
	dma.consumirEventoCambio(newlineaAbono.getIdo(),"iva");
	dma.consumirEventoCambio(newlineaAbono.getIdo(),"mi_empresa");

	dma.addValue(idoAbono,idtoAbono,"línea",new ObjectValue(newlineaAbono));
	dma.consumirEventoCambio(idoAbono,"línea",newlineaAbono.getIdo(),newlineaAbono.getIdto());

	if(inicializado.size()==0){
		for(Object dato: inicializData){
			ObjValue ov=(ObjValue)dato;			
			dma.printRule("clonando propiedad "+ov.getPROPNAME());
			dma.setValue(idoAbono,idtoAbono,ov.getPROPNAME(),ov.getOBJECTVALUE());
			dma.consumirEventoCambio(idoAbono,ov.getPROPNAME());	
		}
	}

end

/* lo comento por rendimineto, ya que seria dificil atender a bloqueos de linea            		
rule "LOS ABONOS DE UN PRODUCTO NO PUEDEN EXCEDER LA CANTIDAD VENDIDA"
salience -100
agenda-group "rules" when 
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="DOCUMENTO_COMERCIAL")
	Lock(IDTO==idtoAbono,idoVenta:IDO,STATE==Constants.INDIVIDUAL_STATE_LOCK)
	ObjValue(IDO==idoVenta, PROPNAME=="línea",idolineaVenta:IDOVALUE!=null)	
	ObjValue(IDO==idoLineaVenta, PROPNAME=="producto",idoProducto:IDOVALUE!=null,idtoProducto:VALUECLS)	
	not(FactHierarchy(IDTO==idtoProducto,CLASSSUP=="ARTÍCULO_FINANCIERO"))		
	Individual(producto:ID!=null)
    
    cantidadVentas: Double() 
   	from accumulate(
             	(and 
             	    ObjValue(IDO==idoVenta, PROPNAME=="línea",linea:VALOR!=null)
				    ObjValue(ID==linea,PROPNAME=="producto",IDOVALUE==idoProducto)
   					DatValue(ID==linea,PROPNAME=="cantidad",cantidad:DOUBLEVALUE!=null)
             		forall( ObjValue(ID==lineaVenta,partidaProp:PROPNAME=="lote"||=="n._serie"||=="talla"||=="color", partidaIdent:VALOR!=null)
							ObjValue(ID==linea,PROPNAME==partidaProp, VALOR==partidaIdent))					
			    ),
			    sum(cantidad))
	cantidadAbonos: Double() 
   	from accumulate(
             	(and 
	             	ObjValue(VALOR==ticketVenta, PROPNAME=="rectifica_a",abono:ID!=null)
             		ObjValue(ID==abono, PROPNAME=="línea",linea:VALOR!=null)
             		ObjValue(ID==linea,PROPNAME=="producto", IDOVALUE==idoProducto)
             		DatValue(ID==linea,PROPNAME=="cantidad",cantidadabonada:DOUBLEVALUE!=null)
             		forall( ObjValue(ID==lineaVenta,partidaProp:PROPNAME=="lote"||=="n._serie"||=="talla"||=="color", partidaIdent:VALOR!=null)
							ObjValue(ID==linea,PROPNAME==partidaProp, VALOR==partidaIdent))						
			    ),
			    sum(cantidadabonada))
	eval(cantidadAbonos+cantidadVentas<0)
	eval(cantidadAbonos>0)//hay que asegurar que hay abonos

then
	dma.printRule("\n\n===========RULE LOS ABONOS DE UN PRODUCTO NO PUEDEN EXCEDER LA CANTIDAD VENDIDA: cantidadNetaVendida"+cantidadAbonos+cantidadVentas);
	String codigopr=dma.getValue(idoProducto,idtoProducto,"rdn").getValue_s();
	throw new OperationNotPermitedException("Los abonos del producto "+ dma.getDDM().getAliasOfClass(idtoProducto)+" '"+codigopr+"' exceden la cantidad comprada en " + (cantidadAbonos+cantidadVentas) +" unidades");
end

rule "CARGA DE ABONOS SOBRE  UN TICKET DE VENTA ANTES DE BORRARLO"
salience 100
agenda-group "rules" when 
	
	Individual(CLASSNAME=="TICKET",idticket:ID!=null,idoTicket:IDO,idtoTicket:IDTO,STATE==Constants.INDIVIDUAL_STATE_PREDELETED||==Constants.INDIVIDUAL_STATE_DELETED)
	DatValue(IDO==idoTicket, PROPNAME=="rectificativo",BOOLEANVALOR=="false")
then
	dma.printRule("\n\n$$$$$$$$$$$$$ PRECARGA_RULE: CARGA DE ABONOS SOBRE  UN TICKET DE VENTA ANTES DE BORRARLO ");
	HashMap<String, Value> values=new HashMap<String, Value> ();
	values.put("rectifica_a",new ObjectValue(idoTicket,idtoTicket));
	instance instancefilter=dma.buildInstanceWith("TICKET", values,null,null,null);
	HashSet<IDIndividual> idosAbonos=dma.loadIndividualsWithSatisficedFilter(instancefilter);
	dma.printRule("....abonos encontrados sobre el ticket: "+idticket+"  idosAbonos="+idosAbonos);
end*/


rule "PRECARGA ARTICULO FINANCIERO"
salience -100 
agenda-group "rules" when 
	  
	FactHierarchy(tipoProductoFinan:IDTO,CLASSSUP=="ARTÍCULO_FINANCIERO")
	//ObjValue(RANGENAME==tipoProductoFinan,idoArtFin:IDOVALUE!=null)
	not(Individual(IDTO==tipoProductoFinan))
then
	dma.printRule("\n\n ================  PRECARGA ARTICULO FINANCIERO ================");
	HashMap<String,Value> where=new HashMap<String,Value>();
	instance  filter=dma.buildInstanceWith("ARTÍCULO_FINANCIERO",where,null,null,null);
	HashSet<IDIndividual> idos=dma.loadIndividualsWithSatisficedFilter(filter);
end


rule "TARJETA REGALO: DESACTIVAR EN ELIMINACION"
	salience -100
 	agenda-group "rules"
	when 
		FactHierarchy(idtoTarjeta:IDTO,CLASSSUP=="CRÉDITO_TARJETA")
		ObjValue(IDTO==idtoTarjeta,idoTarjeta:IDO, PROPNAME=="documento_activación", idoVenta:IDOVALUE!=null,idtoVenta:VALUECLS)
		Individual(IDO==idoTarjeta,STATE==Constants.INDIVIDUAL_STATE_DELETED)
		eval( dma.preload(idoVenta, idtoVenta) )
		ObjValue(IDO==idoVenta,PROPNAME=="línea",idoLinF:IDOVALUE,linea:OBJECTVALUE)
		ObjValue(IDO==idoLinF,PROPNAME=="tarjeta",IDOVALUE==idoTarjeta)
	then
	 	dma.printRule("===========TARJETA REGALO: DESACTIVAR EN ELIMINACION");	 	
	 	dma.delValues(new Domain(linea),"tarjeta");	
end	


rule "TARJETA REGALO: CREACIÓN EN ABONO HABIENDO PASADO PLAZO DEVOLUCION CON DINERO"
	no-loop true
 	agenda-group "rules"
	when 
		FactHierarchy(idtoAbono:IDTO,CLASSSUP=="TICKET"||=="RECTIFICACIÓN")
	
		Lock(IDTO==idtoAbono,idoAbono:IDO<0,STATE==Constants.INDIVIDUAL_STATE_LOCK)//antes tenía lockedbyuser=true ¿pq?, se ha quitado porque ahora tb hay reglas que crean tickets de abono
		forall(	FactHierarchy(IDTO==idtoAbono,CLASSSUP=="TICKET")		
				DatValue(IDO==idoAbono, PROPNAME=="rectificativo",BOOLEANVALOR=="true"))
							
		FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")
		Individual(CLASSNAME==tipoProducto, idoProFinan:IDO, idtoProFinan:IDTO)
		ObjValue(IDO==idoProFinan, PROPNAME=="empresa", idoEmpresa:IDOVALUE!=null)
				    											 		
		importeDoc: Double(doubleValue<0.0)
           	from accumulate((and 	ObjValue(IDO==idoAbono, PROPNAME=="desglose_iva", idoDesglose:IDOVALUE)
           							ObjValue(IDO==idoDesglose, PROPNAME=="mi_empresa", IDOVALUE==idoEmpresa)
									DatValue(IDO==idoDesglose, PROPNAME=="importe", base:QMIN!=null)), 
									sum(base))
									
		DatValue(IDO==idoAbono, PROPNAME=="fecha", fechaAbono:QMIN!=null)
		
		fechaCargo:Double() from accumulate((and 	ObjValue(IDO==idoAbono,PROPNAME=="rectifica_a",idoCargo:IDOVALUE)
													DatValue(IDO==idoCargo, PROPNAME=="fecha", f:QMIN!=null)) sum(f))
		
		
		//Si el usuario edita una linea esta regla le hace perder el foco
		not((and  	ObjValue(IDO==idoAbono,PROPNAME=="línea", idoLineaAny:IDOVALUE!=null)
					Lock(IDO==idoLineaAny, LOCKEDBYUSER==true)))	
		
		not((and 	ObjValue(IDO==idoAbono, PROPNAME=="línea", idoLinea:IDOVALUE!=null)     
				    FactHierarchy(tipoProductoAny:CLASS, CLASSSUP=="ARTÍCULO_FINANCIERO")							
				    ObjValue(IDO==idoLinea, PROPNAME=="producto", RANGENAME==tipoProductoAny, prod:OBJECTVALUE)))
	    
		//La configuración de TICKETS tiene que especificar el número de días en los que es posible abonar con tarjeta:
		//	- Nº días abonable != null && > 0.
		//	- Nº días permite abono dinero != null < Nº días abonable.
		//	- Fecha del documento > Nº días permite abono dinero && < Nº días abonable
		ObjValue(CLASSNAME=="MI_EMPRESA"||=="APLICACIÓN", PROPNAME=="config_tickets", idoConfigTickets:IDOVALUE!=null, idtoConfigTickets:VALUECLS)
		eval( dma.preload(idoConfigTickets, idtoConfigTickets) )		
		//Si es cero, no se permiten abonos:
		DatValue(IDO==idoConfigTickets, PROPNAME=="período_días_abonable", periodoAbonable:INTVALUE) 	
		//Si es igual al periodoAbonable, no se permiten abonos con tarjeta regalo:
		DatValue(IDO==idoConfigTickets, PROPNAME=="período_días_abonar_con_dinero", periodoAbonarConDinero:INTVALUE) //<periodoAbonable&&>=0
		
	then
	 	dma.printRule("===========TARJETA REGALO: CREACIÓN EN ABONO HABIENDO PASADO PLAZO DEVOLUCION CON DINERO "+importeDoc);
	 	
	 	//Obtenemos la fecha en la que se hace el abono (ahora mismo) y en la que se creó el documento y 
	 	//comprobamos cuantos días han pasado:

		if(fechaCargo.longValue()==0) fechaCargo=fechaAbono;
		
	 	Long separacion = fechaAbono.longValue()-fechaCargo.longValue();
	 	separacion = separacion / (60*60*24); //Pasamos de milisegundos a días.

		dma.printRule("FECHAS separacion "+separacion +" ab:"+fechaAbono+ " car:"+fechaCargo);
	 	if(separacion >= periodoAbonarConDinero && separacion <= periodoAbonable){		 	
		 	Domain dominioTarjeta = dma.creaIndividualOfClass("CRÉDITO_TARJETA");
			dma.setValue(dominioTarjeta,"producto",new ObjectValue(idoProFinan,idtoProFinan));
			dma.setValue(dominioTarjeta,"saldo_máximo",new DoubleValue(Auxiliar.redondea(-importeDoc,2)));
			dma.setValue(dominioTarjeta,"saldo",new DoubleValue(0,0));			
			dma.setValue(dominioTarjeta,"documento_activación",new ObjectValue(idoAbono,idtoAbono));	
			dma.setValue(dominioTarjeta,"descuento",new DoubleValue(0,0));
			
			Calendar calendario = Calendar.getInstance();
			calendario.set(calendario.get(Calendar.YEAR)+1,calendario.get(Calendar.MONTH),1);
			dma.setValue(dominioTarjeta,"garantía_caducidad",new TimeValue(calendario.getTimeInMillis()/Constants.TIMEMILLIS));	 	
				
		   	Domain domLinea = dma.creaIndividualOfClass("LÍNEA_ARTÍCULOS_FINANCIERA");
			dma.setValue(domLinea,"producto",new ObjectValue(idoProFinan,idtoProFinan));
			dma.setValue(domLinea,"cantidad", new DoubleValue(1.0));	// da igual porque se machaca al activarse
			dma.setValue(domLinea,"tarjeta",new ObjectValue(dominioTarjeta));
			
			Domain domDoc = new Domain(idoAbono,idtoAbono);
			
			//Añadimos la línea financiera al documento de abono.
			dma.addValue(domDoc,"línea",new ObjectValue(domLinea));
		}else{
			dma.printRule("[DEVOLUCIÓN CON TARJETA REGALO] Se devuelve con dinero, ya que no está en el plazo de devolver con tarjeta");
		}
end			    

rule "TARJETA REGALO: CREACION EN VENTA"
	no-loop true
 	agenda-group "rules"
	when 
		FactHierarchy(idtoDocumento:IDTO,CLASSSUP=="DOCUMENTO_COMERCIAL")
	
		Lock(IDTO==idtoDocumento,idoDocumento:IDO<0,STATE==Constants.INDIVIDUAL_STATE_LOCK)//antes tenía lockedbyuser=true ¿pq?, se ha quitado porque ahora tb hay reglas que crean tickets de abono

		FactHierarchy(idtoLinea:IDTO, CLASSSUP=="LÍNEA_ARTÍCULOS_FINANCIERA")
		ObjValue(IDO==idoDocumento, PROPNAME=="línea", idoLinea:IDOVALUE,VALUECLS==idtoLinea)    
		not Lock(IDO==idoLinea,LOCKEDBYUSER==true) 
								
		ObjValue(IDO==idoLinea, PROPNAME=="producto", idtoProFin:VALUECLS, idoProFinan:IDOVALUE,prod:OBJECTVALUE)		
		
		not ObjValue(IDO==idoLinea,PROPNAME=="tarjeta") //no actua si ha sido eliminada la tarjeta				
		    											 		
		DatValue(IDO==idoLinea, PROPNAME=="importe", importeFin:DOUBLEVALUE>0 )
		DatValue(IDO==idoDocumento, PROPNAME=="fecha", fechaDocumento:QMIN!=null)
		
		//Si el usuario edita una linea esta regla le hace perder el foco
		not((and  	ObjValue(IDO==idoDocumento,PROPNAME=="línea", idoLineaAny:IDOVALUE!=null)
					Lock(IDO==idoLineaAny, LOCKEDBYUSER==true)))		 
		ObjValue(IDO==idoDocumento, PROPNAME=="delegación",idoDelegacion:IDOVALUE!=null)
		DatValue(IDO==idoDelegacion,PROPNAME=="rdn",rdnDel:VALOR!=null)   		
	then
	 	dma.printRule("===========TARJETA REGALO: CREACION EN VENTA");
	 	
	 	//Obtenemos la fecha en la que se hace el abono (ahora mismo) y en la que se creó el documento y 
	 	//comprobamos cuantos días han pasado:
		 	Domain dominioTarjeta = dma.creaIndividualOfClass("CRÉDITO_TARJETA");
		 	if(dma.getDDM().classIndexed(dma.getIdClass("CRÉDITO_TARJETA"))){
		 		String rdnT=rdnDel+"&"+dominioTarjeta.getIdo()+"&";
		 		dma.setValue(dominioTarjeta,"rdn",new StringValue(rdnT));
		 	}
			dma.setValue(dominioTarjeta,"producto",new ObjectValue(idoProFinan,idtoProFin));
			dma.setValue(dominioTarjeta,"saldo_máximo",new DoubleValue(Auxiliar.redondea(importeFin,2)));
			dma.setValue(dominioTarjeta,"saldo",new DoubleValue(0,0));			
			dma.setValue(dominioTarjeta,"documento_activación",new ObjectValue(idoDocumento,idtoDocumento));	
			dma.setValue(dominioTarjeta,"descuento",new DoubleValue(0,0));
			
			Calendar calendario = Calendar.getInstance();
			calendario.set(calendario.get(Calendar.YEAR)+1,calendario.get(Calendar.MONTH),1);
			dma.setValue(dominioTarjeta,"garantía_caducidad",new TimeValue(calendario.getTimeInMillis()/Constants.TIMEMILLIS));	 	
				
		   	Domain domLinea = new Domain(idoLinea,idtoLinea);
			dma.setValue(domLinea,"producto",new ObjectValue(idoProFinan,idtoProFin));			
			dma.setValue(domLinea,"tarjeta",new ObjectValue(dominioTarjeta));
			
			Domain domDoc = new Domain(idoDocumento,idtoDocumento);					
end			    

rule "TARJETA REGALO: EMPRESA"
 	agenda-group "rules"
	when 
		FactHierarchy(idtoLinea:IDTO, CLASSSUP=="LÍNEA_ARTÍCULOS_FINANCIERA")
		Individual(idoLinea:IDO, IDTO==idtoLinea,STATE==Constants.INDIVIDUAL_STATE_READY)
		ObjValue(IDO==idoLinea,PROPNAME=="tarjeta",idoTarjeta:IDOVALUE<0,idtoTarjeta:VALUECLS)		
		ObjValue(IDO==idoLinea,PROPNAME=="producto",prodLinea:IDOVALUE!=null)
		ObjValue(IDO==prodLinea,PROPNAME=="empresa",OBJECTVALUE!=null,RANGENAME=="MI_EMPRESA",miEmpreProducto:OBJECTVALUE!=null)	     												
	then
	 	dma.printRule("===========TARJETA REGALO: EMPRESA");
		dma.setValue(idoTarjeta,idtoTarjeta,"mi_empresa",miEmpreProducto);	 			
end	


rule "PAGO A PROVEEDORES CON TARJETA REGALO"
salience 120 //Mayor prioridad que la que calcula el importe de la factura.
agenda-group "rules"
	when
		
		FactHierarchy(classRoot:CLASS,CLASSSUP=="DOCUMENTO_COMPRA")
		Individual(idRoot:ID, idoRoot:IDO, idtoRoot:IDTO, CLASSNAME==classRoot)
		DatValue(IDO==idoRoot, PROPNAME=="importe", importe:DOUBLEVALUE>0 ) //Importe con IVA
		
		//Se ha creado una línea financiera con producto financiero y cantidad
		//	-> No tiene todavía una tarjeta regalo.
		//  -> La cantidad será el importe total de la tarjeta regalo
		ObjValue(IDO==idoRoot, PROPNAME=="línea", RANGENAME=="LÍNEA_ARTÍCULOS_FINANCIERA", idoLinea:IDOVALUE!=null)
		ObjValue(IDO==idoLinea, idtoLinea:IDTO, PROPNAME=="producto", idoProFinan:IDOVALUE!=null)
		DatValue(IDO==idoLinea, PROPNAME=="cantidad", cantidad:INTVALUE>0)
		precioConIVA: Double() 
		    from accumulate(
					DatValue(IDO==idoLinea, PROPNAME=="precio_iva_incluido", precio:DOUBLEVALUE>0),
				sum(precio)
			)
		DatValue(IDO==idoLinea, PROPNAME=="precio", precioSinIVA:DOUBLEVALUE>0)
		ObjValue(IDO==idoLinea, PROPNAME=="iva", idoIva:IDOVALUE!=null)
		DatValue(IDO==idoIva, PROPNAME=="porcentaje_iva", porcentajeIVA:DOUBLEVALUE)		
		nDigitosPrecio: ArrayList() from collect(DatValue(CLASSNAME=="APLICACIÓN", IDO!=null,PROPNAME=="n._dígitos_en_precio",INTVALUE>0))				
		not( ObjValue(IDO==idoLinea, PROPNAME=="tarjeta", VALOR!=null) )
		not( ObjValue(IDO==idoLinea, PROPNAME=="importe", VALOR!=null) )

		FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")	
		Individual(CLASSNAME==tipoProducto, IDO==idoProFinan, idtoProFinan:IDTO)
		
	then
		dma.printRule("[PAGO A PROVEEDORES CON TARJETA REGALO]");
		
		//precio será el precio CON IVA, si no tiene todavía, lo calculamos a partir del precio SIN IVA
		Double precio = 0D;
		if(precioConIVA.equals(0.0) || precioConIVA == null){
			//Si no ha acumulado un precio con iva, lo calculamos.
			precio = precioSinIVA * (1D + (porcentajeIVA / 100D));
		}else{
			precio = precioConIVA;
			//dma.printRule(">>>> final CON IVA encontrado. precio: "+precio);			
		}
		
		Domain dominioTarjeta = dma.creaIndividualOfClass("CRÉDITO_TARJETA");
		dma.setValue(dominioTarjeta,"producto",new ObjectValue(idoProFinan,idtoProFinan));
		dma.setValue(dominioTarjeta,"saldo",new DoubleValue(0,0));			
		dma.setValue(dominioTarjeta,"saldo_máximo",new DoubleValue(cantidad.doubleValue()));			
		dma.setValue(dominioTarjeta,"documento_activación",new ObjectValue(idoRoot,idtoRoot));	
		
		Double descuento = 0D;
		if((cantidad*precio) > (importe-(cantidad*precio))){
			dma.printRule(">>> cantidad*precio: "+cantidad+", "+precio+", importe: "+importe);		
			descuento = 100-((importe*100)/(cantidad*precio));
		}
		dma.setValue(dominioTarjeta, "descuento", new DoubleValue(descuento));
		dma.setValue(idoLinea, idtoLinea, "descuento", new DoubleValue(descuento));
		dma.setValue(idoLinea, idtoLinea, "cantidad", new DoubleValue(cantidad.doubleValue()*-1));
		
			
		Calendar calendario = Calendar.getInstance();
		calendario.set(calendario.get(Calendar.YEAR)+1,calendario.get(Calendar.MONTH),1);
		dma.setValue(dominioTarjeta,"garantía_caducidad",new TimeValue(calendario.getTimeInMillis()/Constants.TIMEMILLIS));	
		
		//Enganchamos la tarjeta regalo a la línea financiera:
		dma.setValue(idoLinea, idtoLinea, "tarjeta", new ObjectValue(dominioTarjeta));
end

rule "ACTUALIZACIÓN PAGO A PROVEEDOR CON TARJETA REGALO"
agenda-group "rules"
salience -100
	when
		
		FactHierarchy(classRoot:CLASS,CLASSSUP=="DOCUMENTO_COMPRA")
		Individual(idRoot:ID, idoRoot:IDO, idtoRoot:IDTO, CLASSNAME==classRoot)
		DatValue(IDO==idoRoot, PROPNAME=="importe", importe:DOUBLEVALUE!=0 ) //Importe con IVA	
		
		ObjValue(IDO==idoRoot, PROPNAME=="línea", RANGENAME=="LÍNEA_ARTÍCULOS_FINANCIERA", idoLinea:IDOVALUE!=null)
		ObjValue(IDO==idoLinea, idtoLinea:IDTO, PROPNAME=="producto", idoProFinan:IDOVALUE!=null)
		DatValue(IDO==idoLinea, PROPNAME=="cantidad", cantidad:INTVALUE<0)
				precioConIVA: Double() 
		    from accumulate(
					DatValue(IDO==idoLinea, PROPNAME=="precio_iva_incluido", precio:DOUBLEVALUE>0),
				sum(precio)
			)
		DatValue(IDO==idoLinea, PROPNAME=="precio", precioSinIVA:DOUBLEVALUE>0)
		ObjValue(IDO==idoLinea, PROPNAME=="iva", idoIva:IDOVALUE!=null)
		DatValue(IDO==idoIva, PROPNAME=="porcentaje_iva", porcentajeIVA:DOUBLEVALUE)		
		nDigitosPrecio: ArrayList() from collect(DatValue(CLASSNAME=="APLICACIÓN", IDO!=null,PROPNAME=="n._dígitos_en_precio",INTVALUE>0))	
		DatValue(IDO==idoLinea, PROPNAME=="descuento", descuento:DOUBLEVALUE!=null)
		ObjValue(IDO==idoLinea, PROPNAME=="tarjeta", idoTarjeta:IDOVALUE!=null, idtoTarjeta:VALUECLS)
		
		FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")	
		Individual(CLASSNAME==tipoProducto, IDO==idoProFinan, idtoProFinan:IDTO)
	then
		dma.printRule("[ACTUALIZACIÓN PAGO A PROVEEDOR CON TARJETA REGALO]");		
		
		//precio será el precio CON IVA, si no tiene todavía, lo calculamos a partir del precio SIN IVA
		Double precio = 0D;
		if(precioConIVA.equals(0.0) || precioConIVA == null){
			//Si no ha acumulado un precio con iva, lo calculamos.
			precio = precioSinIVA * (1D + (porcentajeIVA / 100D));
		}else{
			precio = precioConIVA;
			//dma.printRule(">>>> final CON IVA encontrado. precio: "+precio);			
		}
		
		Double incrementoDescuento = importe/(cantidad*precio)*100;
		Double nuevoDescuento = descuento + incrementoDescuento;	
		dma.printRule(">>> incrementoDescuento: "+incrementoDescuento);	
		dma.printRule(">>> nuevoDescuento: "+nuevoDescuento);	
				
		dma.setValue(idoTarjeta, idtoTarjeta, "descuento", new DoubleValue(nuevoDescuento));
		dma.setValue(idoLinea, idtoLinea, "descuento", new DoubleValue(nuevoDescuento));
end	


rule "PRECARGA CREDITO"
salience 100 
no-loop true
agenda-group "rules" when 
  	  	
	FactHierarchy(classRoot:CLASS, CLASSSUP=="DOCUMENTO_VENTA") 
	//debo precargar aunque no esté bloqueado, ya que en abonos el ticket de venta no está bloqueado y debo conocer la tarjeta antes de crear las lineas de abono
	Individual(idRoot:ID,idoRoot:IDO,idtoRoot:IDTO,CLASSNAME==classRoot)
	ObjValue(ID==idRoot,PROPNAME=="línea",idLinea:VALOR!=null)     
    FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")							
    ObjValue(ID==idLinea,PROPNAME=="producto", RANGENAME==tipoProducto,prod:OBJECTVALUE)										
    ObjValue(ID==idLinea,PROPNAME=="tarjeta", idoSerie:IDOVALUE,serie:OBJECTVALUE!=null)
	not(DatValue(CLASSNAME=="CRÉDITO_TARJETA",IDO==idoSerie))																															    
then
		dma.printRule("\n\n ================PRECARGA CREDITO serie "+serie);
		
	 	dma.ruleGetFromServer(serie.getValue(),serie.getValueCls(),1,false);		
end

/*PRECARGAR TARJETA SI ELIMINO TICKET CON PRODUCTO FINANCIERO PARA QUE RESTAURE

SI SE BORRA UN TICKET QUE ACTIVA UNA TARJETA TRATO DE BORRAR LA TARJETA

LIMPIAR NUEVA TARJETA DEVOLUCION SI TIENE SALDO CERO*/

rule "ACTUALIZACIÓN SALDO CREDITO" 
salience 150
 agenda-group "rules" when 
  	
	DatValue(idoCredito:IDO,idCredito:ID,idtoCredito:IDTO,CLASSNAME=="CRÉDITO_TARJETA",PROPNAME=="rdn",rdnCredito:VALOR!=null)
    Individual(ID==idCredito,STATE==Constants.INDIVIDUAL_STATE_READY)
    ObjValue(ID==idCredito,PROPNAME=="producto", idProducto:VALOR!=null)			
                              	
	contributionInit: Double() 
    	from accumulate((and	
							FactHierarchy(classRoot:CLASS, tipoDoc:CLASSSUP=="DOCUMENTO_VENTA"||=="DOCUMENTO_COMPRA")    																	
							ObjValue(idRoot:ID,CLASSNAME==classRoot,PROPNAME=="línea",idLinea:INITIALVALOR)
														
						    FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")							
    						ObjValue(ID==idLinea,PROPNAME=="producto", INITIALVALOR==idProducto,RANGENAME==tipoProducto)		
    											  														 						
    						ObjValue(ID==idLinea,PROPNAME=="tarjeta", INITIALVALOR==idCredito)							    													
							DatValue(ID==idLinea,PROPNAME=="cantidad", cantidadInitial:INITIALDOUBLE)),
                                   		
                      		sum(cantidadInitial*(tipoDoc.equals("DOCUMENTO_COMPRA")?-1:1)))
	contributionCurr: Double() 
    	from accumulate((and
							FactHierarchy(classRoot:CLASS, tipoDoc:CLASSSUP=="DOCUMENTO_VENTA"||=="DOCUMENTO_COMPRA")    	    	
							Individual(idRoot:ID,CLASSNAME==classRoot,STATE==Constants.INDIVIDUAL_STATE_READY)
							ObjValue(ID==idRoot,PROPNAME=="línea",idLinea:VALOR)							
														    				
						    FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")															    														
    						ObjValue(ID==idLinea,PROPNAME=="producto", VALOR==idProducto,RANGENAME==tipoProducto)		
									 						
    						ObjValue(ID==idLinea,PROPNAME=="tarjeta", IDOVALUE==idoCredito)							    													
							DatValue(ID==idLinea,PROPNAME=="cantidad", cantidad:DOUBLEVALUE)),
							
							sum(cantidad*(tipoDoc.equals("DOCUMENTO_COMPRA")?-1:1)))
	DatValue(CLASSNAME=="APLICACIÓN", idoApp:IDO,PROPNAME=="n._dígitos_en_importe_linea",digitosRedondeo:INTVALUE>0)							                     
then
	dma.printRule("\n\n =====ACTUALIZACIÓN SALDO CREDITO " +contributionInit+","+contributionCurr );	
			 
	dma.setIncrementalValue(idoCredito,idtoCredito,dma.getIdProperty("saldo"),contributionCurr-contributionInit,digitosRedondeo);			
end

rule "TARJETA CREDITO REGALO: CONSUMO" 
//La tarejta es usada cuando ya existía y se vincula a un doc de venta

salience -50
 agenda-group "rules" when 
  	//Dado que el importe del doc queremos que sea cero, si no es cero, represetna lo que falta por abonar
  	//El saldo y el saldo maximo son iva no incluido
	FactHierarchy(classRoot:CLASS, CLASSSUP=="DOCUMENTO_VENTA") 
	IndividualState(idoDocumento:IDO,CLASSNAME==classRoot,STATE==Constants.INDIVIDUAL_STATE_LOCK||==Constants.INDIVIDUAL_STATE_DELETED)
	FactHierarchy(idtoLinea:IDTO,CLASSSUP=="LÍNEA_ARTÍCULOS_FINANCIERA")
	ObjValue(IDO==idoDocumento,PROPNAME=="línea",VALUECLS==idtoLinea,idoLinea:IDOVALUE!=null,linea:OBJECTVALUE)         							    										    
    ObjValue(IDO==idoLinea,PROPNAME=="tarjeta", idoTarjeta:IDOVALUE!=null)	        
    DatValue(IDO==idoTarjeta,PROPNAME=="garantía_caducidad",caducidad:QMIN!=null)
	eval(caducidad*Constants.TIMEMILLIS>System.currentTimeMillis())
	
	baseDoc: Double()
           	from accumulate((and 	ObjValue(IDO==idoDocumento, PROPNAME=="desglose_iva", idoDesglose:IDOVALUE)
           							forall(	ObjValue(IDO==idoTarjeta,PROPNAME=="mi_empresa", idoEmpT:IDOVALUE!=null)
           									ObjValue(IDO==idoDesglose, PROPNAME=="mi_empresa", IDOVALUE==idoEmpT))
									DatValue(IDO==idoDesglose, PROPNAME=="importe", base:QMIN!=null)), 
									sum(base))	
									
	baseDocPrev: Double()
           	from accumulate((and 	ObjValue(IDO==idoDocumento, PROPNAME=="desglose_iva", idoDesglose:IDOVALUE)
           							forall(	ObjValue(IDO==idoTarjeta,PROPNAME=="mi_empresa", idoEmpT:IDOVALUE!=null)
           									ObjValue(IDO==idoDesglose, PROPNAME=="mi_empresa", IDOVALUE==idoEmpT))
									DatValue(IDO==idoDesglose, PROPNAME=="importe", base:PREVIODOUBLEVALUE!=null)), 
									sum(base))									     												
							
	                      

	DatValue(IDO==idoTarjeta,PROPNAME=="saldo_máximo",saldoMaximo:DOUBLEVALUE!=null)
	
	DatValue(IDO==idoTarjeta,PROPNAME=="saldo",saldo:DOUBLEVALUE!=null)
	DatValue(IDO==idoLinea, PROPNAME=="precio_iva_incluido", precioLinea:DOUBLEVALUE!=null)

	//la tarjeta no debe consumirse al modificar el ticket original, ni en un abono de dicho ticket
	not(ObjValue(IDO==idoTarjeta,PROPNAME=="documento_activación",IDOVALUE==idoDocumento)) 
	not(ObjValue(IDO==idoDocumento,PROPNAME=="rectifica_a",idTicketV:VALOR) and
		ObjValue(IDO==idoTarjeta,PROPNAME=="documento_activación",VALOR==idTicketV)) 
				

	//eval( Math.min( baseDoc.doubleValue(),saldo.doubleValue())!=0 )
then
	dma.printRule("=================TARJETA CREDITO REGALO: CONSUMO saldo, base "+saldo+","+baseDoc +" prev:"+baseDocPrev);	
	double incremento=0.0;
	if( saldo>saldoMaximo ) saldo=saldoMaximo;
	if( saldo<0 ) saldo=0.0;
	
	if(baseDoc.doubleValue()>0){		
		incremento=Math.min( baseDoc.doubleValue(),saldo.doubleValue());
	}else{
		incremento=-Math.min( -baseDoc.doubleValue(),saldoMaximo.doubleValue()-saldo.doubleValue());
	}
	
	dma.printRule(" incremento pre "+incremento);
	
	dma.printRule(" incremento "+incremento);
	Domain domLinea=new Domain(linea);
	DoubleValue cantidadPrevia=(DoubleValue)dma.getValue(domLinea,"cantidad");
	DoubleValue descuentoLinea=(DoubleValue)dma.getValue(domLinea,"descuento");
	if( descuentoLinea!=null ) precioLinea= precioLinea*(1-descuentoLinea.getNumericValue())/100;
	double incrementoQ=-incremento/precioLinea;

	double nuevaQ=incrementoQ;
	if(cantidadPrevia!=null){
		nuevaQ=incrementoQ+cantidadPrevia.getValueMin();
		dma.printRule(" cant previa nueva q "+nuevaQ);
	}
	
	//if(Math.abs(Auxiliar.redondea(incrementoQ*precioLinea,2))>=0.01){		
		dma.printRule(" cantidadPrevia, nueva "+cantidadPrevia+","+nuevaQ);
		//Un incremento negativo aumenta el saldo de la tarejta, por tanto lo recorto para evitar que dicho saldo supere el maximo
		dma.setValue(domLinea,"cantidad",new DoubleValue(nuevaQ,nuevaQ));	
	//}
end
/*
rule "ABONO TARJETA CREDITO REGALO CON SALDO CONSUMIDO" 
salience -50
 agenda-group "rules" when 
  	
	FactHierarchy(classRoot:CLASS, CLASSSUP=="TICKET")	 
	IndividualState(idRoot:ID,CLASSNAME==classRoot,STATE==Constants.INDIVIDUAL_STATE_LOCK||==Constants.INDIVIDUAL_STATE_DELETED)
	DatValue(ID==idRoot, PROPNAME=="rectificativo",BOOLEANVALOR=="true")
	ObjValue(ID==idRoot,PROPNAME=="línea",idLinea:VALOR!=null,linea:OBJECTVALUE)
	DatValue(ID==idRoot,PROPNAME=="importe",importeDoc:DOUBLEVALUE!=null) 
    FactHierarchy(tipoProducto:CLASS,CLASSSUP=="ARTÍCULO_FINANCIERO")							
    ObjValue(ID==idLinea,PROPNAME=="producto", RANGENAME==tipoProducto,prod:VALOR)										
    ObjValue(ID==idLinea,PROPNAME=="tarjeta", serie:VALOR!=null)
	DatValue(ID==idLinea,PROPNAME=="cantidad", cantidad:DOUBLEVALUE!=null)	
	DatValue(ID==idLinea,PROPNAME=="precio", precio:DOUBLEVALUE!=null)
	DatValue(idCredito:ID==serie,CLASSNAME=="CRÉDITO_TARJETA",PROPNAME=="rdn")	                      
	DatValue(ID==idCredito,PROPNAME=="saldo_máximo",saldoMaximo:DOUBLEVALUE!=null)
	DatValue(ID==idCredito,PROPNAME=="saldo",saldo:DOUBLEVALUE!=null)	
	DatValue(ID==idCredito,PROPNAME=="descuento",descuento:DOUBLEVALUE!=null)	
	ObjValue(ID==idRoot,PROPNAME=="rectifica_a",idTicketV:VALOR) 
	ObjValue(ID==idCredito,PROPNAME=="documento_activación",VALOR==idTicketV)
				
then
	dma.printRule("=================ABONO TARJETA CREDITO REGALO  CON SALDO CONSUMIDO: saldo, importe "+saldo+","+importeDoc +", precio "+precio );	
	//El saldo ya tiene descontado la cantidad a abonar que es la comprada en negativa. Entonces si la tarjeta ya llevaba consumo
	// el saldo es negativo (de lo contrario ya seria cero) y en valor absoluto representa el total consumido. DIcho saldo tengo que
	//descontarlo a la cantidad para que quede a cero

	DoubleValue nuevaQ=new DoubleValue(cantidad-(saldo/(precio*(100-descuento)/100)));
	dma.setValue(new Domain(linea),"cantidad",nuevaQ);
end*/
	
rule "ACTIVACION TARJETA CREDITO REGALO Y ACTUALIZACIÓN SALDO_MAXIMO" 
//La cantidad de la linea (que contribuye al saldo de la tarjeta) coincide con la del documento activacion PROTOTIPO
// sería lo mismo que instalar directamente modificando cantidad linea
	salience -100
	agenda-group "rules"
	when 
	  	
		FactHierarchy(classRoot:CLASS, claseDoc:CLASSSUP=="DOCUMENTO_VENTA") 
		IndividualState(idoRoot:IDO, CLASSNAME==classRoot, LEVEL==Constants.LEVEL_PROTOTYPE, STATE==Constants.INDIVIDUAL_STATE_LOCK||==Constants.INDIVIDUAL_STATE_DELETED)
		ObjValue(IDO==idoRoot, PROPNAME=="línea", idoLinea:IDOVALUE!=null, idtoLinea:VALUECLS)
		ObjValue(IDO==idoLinea, PROPNAME=="mi_empresa", idoEmpresa:IDOVALUE!=null)
		
		DatValue(IDO==idoRoot, PROPNAME=="importe", importeLineaFin:DOUBLEVALUE!=null)
	
	    FactHierarchy(tipoProducto:CLASS, CLASSSUP=="ARTÍCULO_FINANCIERO")			    
	    ObjValue(IDO==idoLinea, PROPNAME=="producto", RANGENAME==tipoProducto,idoProducto:IDOVALUE, prod:VALOR)	    	    
	   	DatValue(IDO==idoLinea, PROPNAME=="precio_iva_incluido", precioLinea:DOUBLEVALUE!=null)	
	   	
	   	importeTicket: Double()
           	from accumulate((and 	ObjValue(IDO==idoRoot, PROPNAME=="desglose_iva", idoDesglose:IDOVALUE)
           							ObjValue(IDO==idoDesglose, PROPNAME=="mi_empresa", IDOVALUE==idoEmpresa)
									DatValue(IDO==idoDesglose, PROPNAME=="importe", base:QMIN!=null)), 
									sum(base))
										   	
	   	//Provisional mientras el precio con iva no se calcule automaticamente a partir del precio sin iva
   		ObjValue(IDO==idoLinea, PROPNAME=="iva", idoIva:IDOVALUE!=null)
		DatValue(IDO==idoIva, PROPNAME=="porcentaje_iva", porcentaje:DOUBLEVALUE)	
		fdigitosPrecio: ArrayList() from collect(DatValue(CLASSNAME=="APLICACIÓN", IDO!=null,PROPNAME=="n._dígitos_en_precio",INTVALUE>0))	
		//XXX
		
	    ObjValue(IDO==idoLinea, PROPNAME=="tarjeta", serie:VALOR!=null)
	    DatValue(IDO==idoLinea, PROPNAME=="cantidad", cantidadPrevia:DOUBLEVALUE!=null)

		ObjValue(idoCredito:IDO, idtoCredito:IDTO, CLASSNAME=="CRÉDITO_TARJETA", PROPNAME=="documento_activación", IDOVALUE==idoRoot)
		DatValue(IDO==idoCredito, PROPNAME=="descuento", descuento:DOUBLEVALUE!=null)	
		DatValue(IDO==idoRoot, PROPNAME=="rectificativo",rectificativo:BOOLEANVALOR)
	then
		dma.printRule("===============ACTIVACION TARJETA CREDITO REGALO "+importeTicket );	
		
		Value saldoMaximoV = dma.getValue(idoCredito, idtoCredito, "saldo_máximo");
		if(saldoMaximoV != null){
			Double saldoMaximo = ((DoubleValue)saldoMaximoV).getNumericValue();
					
			Double precioConIVA = precioLinea;
			
			
			if(claseDoc.equals("DOCUMENTO_VENTA")){
				DoubleValue nuevoSaldoMaximo=null;
				if(rectificativo.booleanValue()){
					nuevoSaldoMaximo = new DoubleValue(Auxiliar.redondea(Math.max(0.0,saldoMaximo - importeTicket),2));//No puede ser negativo pues el vale actuaria como credito sin que haya deuda
				}else{
					nuevoSaldoMaximo = new DoubleValue(Auxiliar.redondea(importeLineaFin,2));
				}				
				
				dma.setValue(idoCredito, idtoCredito, "saldo_máximo", nuevoSaldoMaximo);
				
				DoubleValue nuevaCantidad = new DoubleValue(nuevoSaldoMaximo.getNumericValue()/precioConIVA);	
				dma.setValue(idoLinea, idtoLinea, "cantidad", nuevaCantidad);
				dma.setValue(idoLinea, idtoLinea, "descuento", new DoubleValue(descuento));			
				
			}
		}
end	



rule "TARJETA REGALO: LIMPIAR NUEVA SI TIENE SALDO MÁXIMO CERO Y ES PROTOTIPO"
	agenda-group "bddrules"
	when
	    	
	    //Dada una tarjeta regalo con saldo máximo y saldo a cero....
	    ObjValue(idoTarjeta:IDO, idtoTarjeta:IDTO, CLASSNAME=="CRÉDITO_TARJETA", LEVEL==Constants.LEVEL_PROTOTYPE, objTarjeta:OBJECTVALUE)
	    DatValue(IDO==idoTarjeta, PROPNAME=="saldo_máximo", DOUBLEVALUE==0)
	    DatValue(IDO==idoTarjeta, PROPNAME=="saldo", DOUBLEVALUE==0)

	    //Esa tarjeta aparece en la línea de un documento
	    ObjValue(idoDoc:IDO, idtoDoc:IDTO, PROPNAME=="línea", idoLinea:IDOVALUE!=null, objLinea:OBJECTVALUE)
	    ObjValue(IDO==idoLinea, idtoLinea:IDTO, PROPNAME=="tarjeta", IDOVALUE==idoTarjeta)

	    //Ese documento tiene que se su documento de activación
	    ObjValue(IDO==idoTarjeta, PROPNAME=="documento_activación", IDOVALUE==idoDoc, objDoc:OBJECTVALUE)

	then
		dma.printRule("==================== TARJETA REGALO: LIMPIAR NUEVA SI TIENE SALDO MÁXIMO CERO Y ES PROTOTIPO");
		dma.delValue(idoTarjeta, idtoTarjeta, "documento_activación", objDoc);
		dma.delValue(idoDoc, idtoDoc, "línea", objLinea);
		dma.deleteObject(idoTarjeta, idtoTarjeta);	
end

rule "CANTIDAD NO ES MODIFICABLE EN TICKET EXISTENTES"
salience -300
agenda-group "rules" when 
    ddm:DocDataModel(USERROL!="administrador")
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	Lock(IDTO==idtoVenta,idoTicket:IDO,STATE==Constants.INDIVIDUAL_STATE_LOCK,LEVEL==Constants.LEVEL_INDIVIDUAL)
	ObjValue(IDO==idoTicket, PROPNAME=="línea", idoLinea:IDOVALUE!=null) 
	DatValue(IDO==idoLinea, prop:PROPNAME=="cantidad", hasCHANGED==true)	
then
	dma.printRule("================= CANTIDAD NO ES MODIFICABLE EN TICKET EXISTENTES");
	throw new OperationNotPermitedException("No se puede modificar "+prop);
end

rule "NO ES MODIFICABLE NINGUN CAMPO DIRECTO EN TICKET EXISTENTES"
salience 300
agenda-group "rules" when 
    ddm:DocDataModel(USERROL!="administrador")
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	IndividualState(IDTO==idtoVenta,idoTicket:IDO,STATE==Constants.INDIVIDUAL_STATE_END_LOCK||==Constants.INDIVIDUAL_STATE_DELETED,LEVEL==Constants.LEVEL_INDIVIDUAL)
	DatValue(IDO==idoTicket,PROPNAME=="rdn",rdn:VALOR!=null)
	
	ObjValue(CLASSNAME=="APLICACIÓN", PROPNAME=="delegación",idoMiDelegacion:IDOVALUE!=null)	
	ObjValue(IDO==idoTicket,PROPNAME=="origen",idoOrigen:IDOVALUE!=null)
	//no puedo impedir cambios de totales, como importe total, porque puede ser incoherente debido a haberse limpiado lineas al replicar desde franquicias
	(or exists(IndividualValue(IDO==idoTicket,PROPNAME=="cargos"||=="línea"||=="descuentos_globales"||=="entregado_metálico", initialValuesChanged==true ))
		exists((and ObjValue(IDO==idoTicket,PROPNAME=="cargos"||=="línea"||=="descuentos_globales", idoSub:IDOVALUE)
					DatValue(IDO==idoSub,PROPNAME=="importe"||=="cantidad"||=="descuento",initialValuesChanged==true,qi:INITIALDOUBLE,qc:QMIN!=null)
					eval(Auxiliar.incrementoRelevante(qi,qc,0.009))))
		exists(Individual(IDO==idoTicket,STATE==Constants.INDIVIDUAL_STATE_DELETED))
	)
	//no impido cambio de producto por accion cambio de talla
then

	dma.printRule("================= NO ES MODIFICABLE NINGUN CAMPO DIRECTO EN TICKET EXISTENTES ");
	throw new OperationNotPermitedException("No se puede modificar el ticket "+rdn);
end

rule "NO ES MODIFICABLE STOCK EN TICKET EXISTENTES OTRAS TIENDAS"
salience 300
agenda-group "rules" when 
    ddm:DocDataModel(USERROL!="administrador")
	FactHierarchy(idtoVenta:IDTO,CLASSSUP=="TICKET")
	Lock(IDTO==idtoVenta,idoTicket:IDO,STATE==Constants.INDIVIDUAL_STATE_LOCK,LEVEL==Constants.LEVEL_INDIVIDUAL)
	DatValue(IDO==idoTicket,PROPNAME=="rdn",rdn:VALOR!=null)
	
	ObjValue(CLASSNAME=="APLICACIÓN", PROPNAME=="delegación",idoMiDelegacion:IDOVALUE!=null)	
	ObjValue(IDO==idoTicket,PROPNAME=="origen",idoOrigen:IDOVALUE!=null)
	ObjValue(IDO==idoOrigen,PROPNAME=="delegación",IDOVALUE!=idoMiDelegacion)	
	ObjValue(IDO==idoTicket,PROPNAME=="línea", idoLinea:IDOVALUE)
	ObjValue(IDO==idoLinea,PROPNAME=="producto", initialValuesChanged==true )
then
	dma.printRule("================= NO ES MODIFICABLE STOCK EN TICKET EXISTENTES OTRAS TIENDAS ");
	throw new OperationNotPermitedException("No se puede modificar productos del ticket "+rdn);
end

rule "ENTREGADO METALICO TICKET: DEPENDENCIA ANTICIPOS"
//tambien realicionado con regla ABONOS:DEVUELTO
//soporta hasta dos medios de pagos distintos
salience -50 //menos prioridad que PRECARGA DOCUMENTOS EN ABONO y menos que "CALCULO IMPORTE TOTAL"
agenda-group "rules" when 

	Lock(CLASSNAME=="TICKET_VENTA",idoDoc:IDO,idtoDoc:IDTO,LOCKEDBYUSER==true)
	
	DatValue(IDO==idoDoc, PROPNAME=="importe",importe:DOUBLEVALUE!=null)
	
	entreg_met_docArr:ArrayList() from collect(DatValue(IDO==idoDoc, PROPNAME=="entregado_metálico",met:DOUBLEVALUE!=null))
	
	DatValue(IDO==idoDoc, PROPNAME=="fecha",fechaDoc:QMIN!=null)
	
	//not(ObjValue(IDO==idoDoc,PROPNAME=="cobro_anticipo",IDOVALUE!=null)) 
	anticipoMetalico:Domain()	from accumulate((and 	ObjValue(IDO==idoDoc,PROPNAME=="cobro_anticipo",idoCobroAny:IDOVALUE,idtoC:VALUECLS)
														ObjValue(IDO==idoCobroAny,PROPNAME=="medio_de_pago",idoMedio:IDOVALUE)	
														DatValue(IDO==idoMedio,PROPNAME=="rdn",VALOR=="Metálico")
    				 									),
                      									init(Domain d=new Domain(0,0);),
                      									action( d=new Domain(idoCobroAny,idtoC);),
                      									result(d))
	
	anticipoOtro:Domain()	from accumulate((and 	ObjValue(IDO==idoDoc,PROPNAME=="cobro_anticipo",idoCobroAny:IDOVALUE,idtoC:VALUECLS)
													ObjValue(IDO==idoCobroAny,PROPNAME=="medio_de_pago",idoMedio:IDOVALUE)	
													DatValue(IDO==idoMedio,PROPNAME=="rdn",VALOR!="Metálico")
    				 									),
                      									init(Domain d=new Domain(0,0);),
                      									action( d=new Domain(idoCobroAny,idtoC);),
                      									result(d))
                      									
	DatValue(CLASSNAME=="TIPO_PAGO",idoTarj:IDO,idtoTarj:IDTO,VALOR=="Tarjeta_crédito")
	DatValue(CLASSNAME=="TIPO_PAGO",idoMet:IDO,idtoMet:IDTO,VALOR=="Metálico")   	 
	DatValue(IDO==idoDoc,PROPNAME=="rdn",rdn:VALOR!=null)  		
			 									
	ObjValue(IDO==idoDoc, PROPNAME=="delegación",idoDel:IDOVALUE!=null,idtoDel:VALUECLS)
	
	rectificaciones:ArrayList()	from collect(ObjValue(PROPNAME=="rectifica_a",IDOVALUE!=null))
	
	totalAnticipado:Double() from accumulate((and 	ObjValue(IDO==idoDoc,PROPNAME=="cobro_anticipo",idoCobroAny:IDOVALUE)
													DatValue(IDO==idoCobroAny,PROPNAME=="importe",i:DOUBLEVALUE!=null)
													DatValue(IDO==idoCobroAny,PROPNAME=="rdn", VALOR!="#TEMPORAL")													
    				 						),
                      				  		sum(i)) 		
 					    											
then	
	dma.printRule("===========ENTREGADO METALICO TICKET: DEPENDENCIA ANTICIPOS (del) "+entreg_met_docArr.size()+" "+idoDel+" "+rdn+" "+importe+" "+idoDoc+" "+anticipoMetalico.getIdo()+" total anticipado "+totalAnticipado);
		
	HashSet network=new HashSet();
	network.add(idoDoc);
	ArrayList resto=new ArrayList(rectificaciones);
	
	//primero averiguo todos los ticket relacionados con este cliente. La regla de precarga a cargado todos los ticket posibles navegando por dominio que puedan estar abonando cualquier ticket de memoria, y rango
	//Este algoritmo soporta que un ticket tenga dos padres (rectica a varios)
	int oldSize=resto.size();
	for(int i=0;i<1000;i++){				
		Iterator itrRest=resto.iterator();
		while(itrRest.hasNext()){
			ObjValue opr=(ObjValue)itrRest.next();
			boolean encontrado=false;
			if(network.contains(opr.getIDOVALUE())){
				network.add(opr.getIDO());
				encontrado=true;
			}
			if(network.contains(opr.getIDO())){
				network.add(opr.getIDOVALUE());
				encontrado=true;
			}
			if(encontrado){			
				itrRest.remove();			
				resto.remove(opr);										
			} 		
		}
		if(resto.size()==oldSize) break;
		oldSize=resto.size();
	}	
	
	//incluye todo lo pagado en metalico (siendo lo cargado el positivo) ticket asociados, tanto ancestor como child, exceptuando this. Contra dicha cantidad positiva puedo hacer abono negativo sin superarlo
	double saldoMetalicoResto=0.0; 
	double saldoTarjetaResto=0.0;
	Iterator itr=network.iterator();
	while(itr.hasNext()){	
		Integer ido=(Integer)itr.next();
		if(!ido.equals(idoDoc)){	
			Domain domTick=new Domain(ido,idtoDoc);
			LinkedList<Value> cobros=dma.getValues(domTick,"cobro_anticipo");
			if(cobros.size()==0){
				//seguramente es un abono externo de otra empresa en cuyo caso no se replican los cobros. Deduciré lo pagado si es un cargo, si es abono no lo tengo en cuenta (con lo cual seria posible abonar mas de lo pagado por algun medio) 
				double importeTick=dma.getDoubleValue(domTick,"importe",true);
				double entregMet=dma.getDoubleValue(domTick,"entregado_metálico",true);
				if(importeTick>0){
					double tmpMet=Math.min(entregMet,importeTick);
					saldoMetalicoResto+=tmpMet;
					saldoTarjetaResto+=importeTick-tmpMet;					
				}
			}else{
				for(Value v:cobros){
					Domain d=new Domain((ObjectValue)v);					
					ObjectValue medio=(ObjectValue)dma.getValue(d,"medio_de_pago");
					double importeC= dma.getDoubleValue(d,"importe",true);
					if(medio.getValue().equals(idoTarj)){				
						saldoTarjetaResto+=importeC;
					}
					if(medio.getValue().equals(idoMet)){
						saldoMetalicoResto+=importeC;	
					}
				}
			}
		}
	}	
	dma.printRule("pagado metalico "+saldoMetalicoResto+", tarje "+saldoTarjetaResto);
	Double entreg_met_doc=0.0;
	if(entreg_met_docArr.size()>0){
		entreg_met_doc=((DatValue)entreg_met_docArr.get(0)).getDOUBLEVALUE();
		dma.printRule("Entregado metalico acumulado "+entreg_met_doc);
		//no se puede decidir hasta saber como se paga. Entregado es reseteado por regla ENTREGADO METÁLICO EN TICKET IMPORTE CERO
	}

	//la variable booleana actualizarImporte debia servir para evitar modificar datos si el total pagado con el reparto de anticipos actual ya cuadra, 
	// asi permitimos en casos de ambiguedad (cuando es posible abonar la cantidad actual tanto en tarjeta como metalico por haber saldo cargada a ambos), que el usuario modifique lo propuesto
	//Excepto en importe positivo que se regula por entregado metalico
	boolean actualizarImporte= Auxiliar.incrementoRelevante(importe,totalAnticipado,0.005) || importe.doubleValue()>0;	
	
	double newAnticipado=0.0;
	
	if(entreg_met_docArr.size()>0){//espero este definido el entregado
		double oldValueAnticipoTarjeta= anticipoOtro.getIdo()==0 ?0.0:dma.getDoubleValue(anticipoOtro,"importe",true);		
		double tarjeta=importe-entreg_met_doc;
		if(tarjeta<0 && saldoTarjetaResto>=0) tarjeta=Math.max(tarjeta,-saldoTarjetaResto);		
		
		if(importe.doubleValue()>0 && entreg_met_doc.doubleValue()>=importe.doubleValue() || importe.doubleValue()<0.0 && saldoTarjetaResto<=0.0) tarjeta=0.0;
		
		dma.printRule("Existe importe pendiente "+actualizarImporte +" old tarj "+oldValueAnticipoTarjeta+ " new  "+tarjeta);		
		if(actualizarImporte && Auxiliar.incrementoRelevante(oldValueAnticipoTarjeta,tarjeta,0.005)){
			if(tarjeta!=0.0){	
				dma.printRule("Debe modificarse tarjeta");		
				if(anticipoOtro.getIdo()==0){				
					dma.printRule("CREANDO ANTICIPO TARJETA "+(importe-entreg_met_doc));
					anticipoOtro= dma.creaIndividualOfClass("COBRO_ANTICIPO");		
					dma.addValue(idoDoc,idtoDoc,"cobro_anticipo", new ObjectValue(anticipoOtro));
					dma.setValue(anticipoOtro,"medio_de_pago",new ObjectValue(idoTarj,idtoTarj));
					dma.setValue(anticipoOtro,"fecha",new TimeValue(fechaDoc.longValue()));//es necesario si el ticket estaba incompleto, que no cuente por hoy					
					dma.setValue(anticipoOtro,"importe",new DoubleValue(Auxiliar.redondea(tarjeta,2)));					
				}else{
					dma.printRule("ACTUALIZANDO ANTICIPO TARJETA "+tarjeta);					
					dma.setValue(anticipoOtro,"importe",new DoubleValue(Auxiliar.redondea(tarjeta,2)));	
				}							
			}else{
				if(anticipoOtro.getIdo()!=0){
					dma.printRule("ELIMINANDO ANTICIPO TARJETA");
					dma.deleteObject(anticipoOtro);
				}
			}
		}
		newAnticipado=tarjeta; //lo computo auqnue no haya sido modificado
	}	
	
	double oldValueAnticipoMetalico= anticipoMetalico.getIdo()==0 ?0.0:dma.getDoubleValue(anticipoMetalico,"importe",true);
	double metalico=Math.min(importe,entreg_met_doc);

	//pagable es lo que resta por pagar despues de lo ya pagado con tarjeta
	double pagableMetalico=importe-newAnticipado;
	if(pagableMetalico*metalico<=0.0) metalico=0.0;
		
	if( metalico!=0.0 && Math.abs(pagableMetalico)<Math.abs(metalico)) metalico=pagableMetalico;		//mayor o igual a cero, igual a cero es cuando pagable es cero

	//y no puedo abonar mas de lo cargado en otros ticket		
	if(metalico<0.0 && saldoMetalicoResto>=0) metalico=Math.max(metalico,-saldoMetalicoResto);	
	
	if(entreg_met_doc.doubleValue()==0.0 && importe.doubleValue()>=0.0 || importe.doubleValue()<0.0 && saldoMetalicoResto<=0.0) metalico=0.0;			

	metalico=Auxiliar.redondea(metalico,2);
	
	dma.printRule("Existe importe pendiente " + actualizarImporte + " old Meta " + oldValueAnticipoMetalico + " new met " + metalico);
	
	if(actualizarImporte && Auxiliar.incrementoRelevante(oldValueAnticipoMetalico,metalico,0.005)){
		if( metalico!=0.0){ 			
			dma.printRule("Debe modificarse metalico  (pagable metalico ="+pagableMetalico + " total ant "+newAnticipado);	
			if(anticipoMetalico.getIdo()==0 ){
				dma.printRule("CREANDO ANTICIPO METALICO "+entreg_met_doc);
				anticipoMetalico= dma.creaIndividualOfClass("COBRO_ANTICIPO");		
				dma.addValue(idoDoc,idtoDoc,"cobro_anticipo", new ObjectValue(anticipoMetalico));
				dma.setValue(anticipoMetalico,"medio_de_pago",new ObjectValue(idoMet,idtoMet));
				dma.setValue(anticipoMetalico,"fecha",new TimeValue(fechaDoc.longValue()));//es necesario si el ticket estaba incompleto, que no cuente por hoy
			}else{
				dma.printRule("ACTUALIZANDO ANTICIPO METALICO "+metalico);						
			}		
			dma.setValue(anticipoMetalico,"entregado_metálico",new DoubleValue(entreg_met_doc));
			dma.setValue(anticipoMetalico,"importe",new DoubleValue(metalico));
		}else{
		//elimino cobro metalico si:
		// si importe es positivo, y no ha entregado metalico, esta claro no puede haber anticipo. Pero si importe es negativo y entregado es cero, puede haber anticipo de devolucion
		// o bien es un abono pero no hay suficiente saldo positivo pagado en metalico para devolver
			if( anticipoMetalico.getIdo()!=0){		
				dma.deleteObject(anticipoMetalico);
				dma.printRule("ELIMINANDO ANTICIPO METALICO");	
			}
		}
	}
			
								
	//fecha ultima venta de delegacion para evitar fraude cambio de fecha pc
	dma.setValue(idoDel,idtoDel,"fecha_última_venta",new TimeValue(fechaDoc.longValue()));
end


/*
// Para la versión 2.0 debido a problemas con el borrado de ciclos.
rule "SI SE ELIMINA EL DOCUMENTO DE ACTIVACIÓN DE UNA TARJETA REGALO, SE ELIMINA LA TARJETA"
	agenda-group "rules"
	salience 150
	when
	    	
	    Individual(idoDoc:IDO, estado:STATE==Constants.INDIVIDUAL_STATE_DELETED||==Constants.INDIVIDUAL_STATE_PREDELETED)
	    ObjValue(IDO==idoDoc, idtoDoc:IDTO, PROPNAME=="línea", idoLinea:IDOVALUE!=null, idtoLinea:VALUECLS, objLinea:OBJECTVALUE)    	    
	    eval( dma.preload(idoLinea, idtoLinea) )
	    ObjValue(IDO==idoLinea, PROPNAME=="tarjeta", idoTarjeta:IDOVALUE, objTarjeta:OBJECTVALUE)
	    	    
	    ObjValue(IDO==idoTarjeta, idtoTarjeta:IDTO, CLASSNAME=="CRÉDITO_TARJETA") 
	    DatValue(IDO==idoTarjeta, PROPNAME=="saldo_máximo", saldoMax:DOUBLEVALUE!=null)
	    DatValue(IDO==idoTarjeta, PROPNAME=="saldo", DOUBLEVALUE==saldoMax)
	    ObjValue(IDO==idoTarjeta, PROPNAME=="documento_activación", IDOVALUE==idoDoc, objDoc:OBJECTVALUE)
 
	then
		dma.printRule("\n [TARJETAS REGALO] SI SE ELIMINA EL DOCUMENTO DE ACTIVACIÓN DE UNA TARJETA REGALO, SE ELIMINA LA TARJETA");
		//dma.delValue(idoTarjeta, idtoTarjeta, "documento_activación", objDoc);
		//dma.delValue(idoLinea, idtoLinea, "tarjeta", objTarjeta);
		dma.delValue(idoDoc, idtoDoc, "línea", objLinea);
		dma.deleteObject(idoLinea, idtoLinea);	
		dma.deleteObject(idoTarjeta, idtoTarjeta);	
end
*/



rule "TICKETS: NO ABRIR CAJA SI NO SE PAGA EN METALICO"
agenda-group "rules" when 
	FactHierarchy(idtoTicket:IDTO, CLASSSUP=="TICKET")
	Lock(IDTO==idtoTicket, idoTicket:IDO, STATE==Constants.INDIVIDUAL_STATE_LOCK)
	DatValue(IDO==idoTicket, PROPNAME=="entregado_metálico",entrMetalico:DOUBLEVALUE!=null)
	DatValue(IDO==idoTicket, PROPNAME=="devuelto_metálico",devMetalico:DOUBLEVALUE!=null)
	Model(reportIdto:IDTO, PROPNAME=="targetClass",VALUECLS==idtoTicket,OP==Constants.OP_INTERSECTION)
	Model(IDTO==reportIdto, PROPNAME=="impresión_directa", DEFAULTVALUE=="true", OP=="DEFVAL")
	Fact(reportIdo:IDO, IDTO==reportIdto, PROPNAME=="rdn", VALUE!=null)
then
	dma.printRule("=================TICKETS: ABRIR CAJA SI SE PAGA EN METALICO idoTicket:"+idoTicket+" idtoTicket:"+idtoTicket+" idoReport:"+reportIdo+" idtoReport:"+reportIdto);
	boolean printsequence=entrMetalico.doubleValue()!=0.0 || devMetalico.doubleValue()!=0.0;
	dma.printRule(" secuencia "+printsequence);
	dma.setValue(reportIdo,reportIdto,Constants.PROP_REPORT_EXEC_PRINTSEQUENCE, new BooleanValue(printsequence));
end

rule "TICKETS: MOSTRAR DETALLES ULTIMO TICKET VENDIDO"
agenda-group "bddrules" when 
	FactHierarchy(idtoTicket:IDTO, CLASSSUP=="TICKET")
	Individual(IDTO==idtoTicket, idoTicket:IDO, LEVEL==Constants.LEVEL_PROTOTYPE)
	//Lock(IDTO==idtoTicket, idoTicket:IDO, STATE==Constants.INDIVIDUAL_STATE_LOCK)
	DatValue(IDO==idoTicket, PROPNAME=="entregado_metálico",metalico:DOUBLEVALUE!=null)
	DatValue(IDO==idoTicket, PROPNAME=="devuelto_metálico",devuelto:DOUBLEVALUE!=null)
	DatValue(IDO==idoTicket, PROPNAME=="importe",importe:DOUBLEVALUE!=null)
then
	System.err.println("=================TICKETS: MOSTRAR DETALLES ULTIMO TICKET VENDIDO idoTicket:"+idoTicket+" idtoTicket:"+idtoTicket+" entregado_metalico:"+metalico+" devuelto_metalico:"+devuelto+" importe:"+importe);
	dma.showNoticeMessage("Importe: "+importe+" Entregado: "+metalico+" Devuelto: "+devuelto,true);
end

rule "TICKET: IMPORTES FUNCION METÁLICO"
salience -100
agenda-group "rules" when 
	

	FactHierarchy(cls:CLASSSUP=="TICKET_VENTA",idtoDoc:IDTO)	
	Individual(IDTO==idtoDoc,idoDoc:IDO,STATE==Constants.INDIVIDUAL_STATE_READY)
	entregadoMetalico:DoubleChanged() from accumulate (	DatValue(IDO==idoDoc, PROPNAME=="entregado_metálico",e:DOUBLEVALUE!=null,ch:hasCHANGED),
                              							init( 	DoubleChanged res = new DoubleChanged(0.0,false);),
                              							action( res=new DoubleChanged(e,ch);),                            
                              						result(	res))
                              			
	//ObjValue(IDO==idoDoc, PROPNAME=="medio_de_pago",idoMedioPago:IDOVALUE!=null)
	//DatValue(IDO==idoMedioPago, PROPNAME=="rdn",VALOR=="Metálico")
	DatValue(IDO==idoDoc, PROPNAME=="importe",importe:DOUBLEVALUE!=null,chi:hasCHANGED)
	
	devuelto:Double() from accumulate((and 	ObjValue(IDO==idoDoc, PROPNAME=="cobro_anticipo",idoCobroAnt:IDOVALUE!=null)    										
    										DatValue(IDO==idoCobroAnt,PROPNAME=="devuelto_metálico",i:DOUBLEVALUE!=null)
    										),
    									init(Double res=new Double(0);),action(res+=i;),result(res))   
    eval(entregadoMetalico.isChanged()||chi)
then
	dma.printRule("=================TICKET: IMPORTES FUNCION METÁLICO "+devuelto);
	dma.setValue(idoDoc,idtoDoc,"devuelto_metálico",new DoubleValue(Auxiliar.redondea(devuelto,2)));
	if(entregadoMetalico.getValor().doubleValue()==0.0 && !entregadoMetalico.isChanged()&&chi&&importe.doubleValue()<0)
		dma.setValue(idoDoc,idtoDoc,"entregado_metálico",new DoubleValue(0.0));
end

